/*******************************************************************************
 * Copyright (c) 2018 Annie Hui @ NVCC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *******************************************************************************/
package gui;
import java.io.File;
import java.util.ArrayList;

import compiler.blocks.Program;
import compiler.classes.ClassedProgramParser;
import compiler.main.Settings;
import compiler.parser.Cmds;
import compiler.parser.ProgramParser;
import compiler.parser.StandaloneProgramParser;
import compiler.util.BugTrap;
import examples.Node;
import examples.ResourceTreeBuilder;
import gui.Interruptable.InterruptTrap;


public class Engine {
	public static final boolean Debug = GuiSettings.Debug;
	
	private static final String UserInterrupt = "User Interrupt Received.";

	public MainPanel mainPanel;
	public GuiInputPipe inpipe;
	public GuiOutputPipe outpipe;
	public GuiOutputPipe errpipe;

	private ProgramParser parser;

	private Node resourceTree;

	public Engine() {
		// If the tree cannot be constructed, it will be null.
		resourceTree = new ResourceTreeBuilder().buildTree();
	}
	
	void clearIOinterrupt() {
		GUIOUtils.Get().setInterrupt(null);
		inpipe.setInterrupt(null);
	}
	void setIOinterrupt() {
		Interrupt interrupt = new Interrupt(UserInterrupt);
		GUIOUtils.Get().setInterrupt(interrupt);
		inpipe.setInterrupt(interrupt);
	}

	
	public void callbackRedirectStdout(GuiOutputPipe pipe) {
		this.outpipe = pipe;
		Settings.SetOutstream(pipe);
	}
	public void callbackRedirectStderr(GuiOutputPipe pipe) {
		this.errpipe = pipe;
		Settings.SetErrstream(pipe);
	}
	public void callbackRedirectStdin(GuiInputPipe pipe) {
		this.inpipe = pipe;
	}

	
	public void callbackOpenFile(File file) {
		try {
			// Always clear all interrupts before and after a callback action.
			clearIOinterrupt();
			
			// Load and display processed results.
			mainPanel.resetContents();
			// Disable test menu until the compilation is successful.
			mainPanel.disableTestMenu();

			parser = new StandaloneProgramParser(file);
			parser.preprocess();
			mainPanel.addFilePane(parser.getProgramCmds(), true);

			// Compile.
			parser.compile();
			GUIOUtils.printlnBlue(parser.getProgramCmds().getFilename() + " successfully loaded.");
			mainPanel.enableTestMenu();
			
		} catch (BugTrap e) {
			// Most bugs thrown as bug traps are caught here.
			printErrors(e);
		} catch (Exception e) {
			// Some bugs are generated by the system and not enclosed by a bug trap.
			// Process them as exception here.
			printErrors(e);
		}
		mainPanel.setConsoleSelected();
		
		clearIOinterrupt();
	}

	public void callbackOpenFiles(File[] files) {
		try {
			// Always clear all interrupts before and after a callback action.
			clearIOinterrupt();

			mainPanel.resetContents();
			// Disable test menu until the compilation is successful.
			mainPanel.disableTestMenu();
			
			parser = new ClassedProgramParser(files);
			parser.preprocess();

			ArrayList<Cmds> classCmds = parser.getClassCmds();
			Cmds programCmds = parser.getProgramCmds();

			// Once the files are preprocessed, they can be displayed in file panels.
			if (programCmds!=null) {
				mainPanel.addFilePane(programCmds, true);
			}
			for (Cmds c : classCmds) {
				mainPanel.addFilePane(c, false);
			}

			// Compile.
			parser.compile();
			
			// If compilation is successful, report that the files are successfully loaded.
			if (programCmds!=null) {
				GUIOUtils.printlnBlue(programCmds.getFilename() + " successfully loaded.");
			}
			for (Cmds c : classCmds) {
				GUIOUtils.printlnBlue(c.getFilename() + " successfully loaded.");
			}
			
			mainPanel.enableTestMenu();

		} catch(BugTrap e) {
			// Most bugs thrown as bug traps are caught here.
			printErrors(e);
		} catch (Exception e) {
			// Some bugs are generated by the system and not enclosed by a bug trap.
			// Process them as exception here.
			printErrors(e);
		}
		mainPanel.setConsoleSelected();
		
		clearIOinterrupt();
	}

	public void callbackRun() {
		try {
			// Always clear all interrupts before and after a callback action.
			clearIOinterrupt();

			mainPanel.setConsoleSelected();
			
			Program program = null;

			if (parser!=null) {
				// Set BugTrap to report rawline numbers if line tracking is on.
				BugTrap.setCmds(Settings.tracklines ? parser.getProgramCmds() : null);
				program = parser.getProgram();
			}
			
			if (program!=null) {
				final Program programPointer = program;
				
				// Run the program on a different thread because the program may need IO, which
				// requires blocking. Therefore, it cannot be run on the same thread as the UI.
				Thread newThread = new Thread(new Runnable() {
					@Override
					public void run() {
						try {
							mainPanel.enableTestMenuDuringTest();
							GUIOUtils.printlnBlue("Executing " + programPointer.getFilename() + ": ");
							programPointer.run(inpipe);
							GUIOUtils.printlnBlue("Program finished execution.");
							mainPanel.enableTestMenu();

						} catch (BugTrap e) {
							if (e instanceof InterruptTrap) {
								//try { GUIOUtils.printlnRed("Program terminated by user"); } catch (BugTrap ignore) {}
							}
							// Most bugs thrown as bug traps are caught here.
							printErrors(e);
						} catch (Exception e) {
							// Some bugs are generated by the system and not enclosed by a bug trap.
							// Process them as exception here.
							printErrors(e);
						}
						// When finish running, enable test menu to re-run.
						mainPanel.enableTestMenu();
					}
				});
				newThread.start();
			}
			
		} catch (BugTrap e) {
			if (e instanceof InterruptTrap) {
				//try {GUIOUtils.printlnRed("Program terminated by user");} catch (BugTrap ignore) {}
			}

			// Most bugs thrown as bug traps are caught here.
			printErrors(e);
		} catch (Exception e) {
			// Some bugs are generated by the system and not enclosed by a bug trap.
			// Process them as exception here.
			printErrors(e);
		}
		clearIOinterrupt();
	}

	public void callbackStop() {
		// This call back is to set interrupt regardless of whether there is anything running.
		// Once set, the test menu should be reset to run again.
		setIOinterrupt();
		mainPanel.enableTestMenu();
	}

	public boolean isResourceAvailable() {
		return resourceTree!=null;
	}
	public Node getResourceTree() {
		return resourceTree;
	}
	
	
	static void printErrors(BugTrap e) {
		// to stdout
		try {GUIOUtils.printlnRed(e.getDetails());} catch (BugTrap ignore) {}
		// to stderr
		e.printStackTrace();
	}
	static void printErrors(Exception e) {
		// to stdout
		try {GUIOUtils.printlnRed(e.getMessage());} catch (BugTrap ignore) {}
		// to stderr
		BugTrap.printStackTrace(e);
	}

	
}
